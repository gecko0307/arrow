/*
Copyright (c) 2013 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module board;

private
{
    import std.stdio;
    import std.math;
    import std.algorithm;
    import std.random;
    import derelict.opengl.gl;
    import dlib.math.utils;
    import dlib.image.io.png;
    import engine.graphics.texture;
    import engine.ui.font;
    import engine.ui.text;
    import engine.wrnd;
    import engine.cell;
    import engine.grid;
}

struct Piece
{
    Grid grid;

    int x, y;
    Cell.State state;

    int x2, y2;
    Cell.State state2;
    bool haveSecond = true;

    float rot = 0;

    void init(Grid g)
    {
        grid = g;
    }

    void randomize()
    {
        state = Cell.randomState();
        state2 = Cell.randomState();
        haveSecond = cast(bool)dice(50, 50);
    }

    void setPosition(int x, int y)
    {
        this.x = x;
        this.y = y;
        this.x2 = x + 1;
        this.y2 = y;
        this.rot = 0;
    }

    bool onGround1()
    {
        // If we are on the bottom of the grid
        if (y == grid.height-1)
            return true;

        // If we are on non-empty cell
        uint i;
        if (y == -1)
            i = x;
        else
        {
            uint rowi = grid.width * (y + 1);
            i = rowi + x;
        }
        return (grid[i].state != Cell.State.Empty);
    }

    bool onGround2()
    {
        // If we are on the bottom of the grid
        if (y2 == grid.height-1)
            return true;

        // If we are on non-empty cell
        uint i;
        if (y2 == -1)
            i = x2;
        else
        {
            uint rowi = grid.width * (y2 + 1);
            i = rowi + x2;
        }
        return (grid[i].state != Cell.State.Empty);
    }
    
    bool onGround()
    {
        bool res = onGround1();
        if (haveSecond)
            return res || onGround2();
        else
            return res;
    }

    void moveLeft()
    {
        int px;
        if (haveSecond)
            px = min(x, x2) - 1;
        else
            px = x - 1;
        if (grid.cellIsEmpty(px, y))
        {
            x--;
            x2--;
        }
    }

    void moveRight()
    {
        int px;
        if (haveSecond)
            px = min(x, x2) + 1;
        else
            px = x + 1;
        if (grid.cellIsEmpty(px, y))
        {
            x++;
            x2++;
        }
    }

    void rotateCW()
    {
        if (!haveSecond)
            return;

        float r2 = rot + 90;
        int px = x + cast(int)cos(degtorad(r2));
        int py = y + cast(int)sin(degtorad(r2));
        if (grid.cellIsEmpty(px, py))
        {
            x2 = px;
            y2 = py;
            rot = r2;
        }
    }

    void fall(int spd)
    {
        y += spd;
        y2 += spd;
    }

    Cell* underlyingCell1()
    {
        uint i = grid.width * y + x;
        return &grid[i];
    }

    Cell* underlyingCell2()
    {
        if (haveSecond)
        {
            uint i = grid.width * y2 + x2;
            return &grid[i];
        }
        else
            return null;
    }
}

class Board
{
    Grid grid;

    float cellWidth = 32.0f;
    float cellHeight = 32.0f;

    Piece piece;

    double timer;
    double stepSpeed;
    bool dropping;

    Texture[Cell.State] textures; 
    Texture background;
    Font fontMain;
    Text txtGameOver;
    Text txtRestart;
    Text txtPause;
    
    this()
    {
        grid = new Grid(8, 8);
        piece.init(grid);

        piece.setPosition(grid.width / 2, -1);
        piece.randomize();

        timer = 0.0;
        stepSpeed = 1.0;
        dropping = false;

        textures[Cell.State.Left] = new Texture(loadPNG("data/left.png"));
        textures[Cell.State.Right] = new Texture(loadPNG("data/right.png"));
        textures[Cell.State.Up] = new Texture(loadPNG("data/up.png"));
        textures[Cell.State.Down] = new Texture(loadPNG("data/down.png"));
        textures[Cell.State.Horizontal] = new Texture(loadPNG("data/hor.png"));
        textures[Cell.State.Vertical] = new Texture(loadPNG("data/ver.png"));
        textures[Cell.State.Omni] = new Texture(loadPNG("data/omni.png"));
        textures[Cell.State.Stone] = new Texture(loadPNG("data/stone.png"));
        background = new Texture(loadPNG("data/background.png"));
        
        fontMain = new Font();
        fontMain.init("data/DroidSans.ttf", 12);
        
        txtGameOver = new Text(fontMain);
        txtGameOver.setPos(86, 32 * 8 / 2 + 8);
        txtRestart = new Text(fontMain);
        txtRestart.setPos(45, 32 * 8 / 2 - 16);
        txtPause = new Text(fontMain);
        txtPause.setPos(105, 32 * 8 / 2 - 4);
    }

    void restart()
    {
        gameState = 0;
    
        foreach(ref c; grid)
            c.state = Cell.State.Empty;

        piece.setPosition(grid.width / 2, 0);
        piece.randomize();

        timer = 0.0;
        stepSpeed = 1.0;
        dropping = false;
    }

    void pause()
    {
        if (gameState == 0)
            gameState = 2;
        else if (gameState == 2)
            gameState = 0;
    }

    void dropPiece()
    {
        if (!dropping && !detected && !dropNext)
        {
            stepSpeed = 0.05;
            dropping = true;
        }
    }

    void undropPiece()
    {
        if (dropping && !detected && !dropNext)
        {
            stepSpeed = 1.0;
            dropping = false;
        }
    }

    bool detected = false;
    bool dropNext = false;

    void processGameStep()
    {
        if (dropNext)
        {
            stepSpeed = 0.05;
            if (grid.haveMarkedCells())
                return;
                
            if (grid.haveRotateMarkedCells())
                return;
            
            if (!grid.dropCells())
            {
                dropNext = false;

                detected = grid.detectLines();
                if (detected)
                {
                    grid.markNeighboursToRotate();
                    stepSpeed = 0.7;
                }

                // If no lines detected, prepare the next piece
                if (!detected)
                {
                    stepSpeed = 1.0;
                    piece.randomize();
                    if (nextIsDetermined)
                    {
                        piece.state = next;
                        nextIsDetermined = false;
                    }
                }
            }
        }
        else if (detected)
        {
            stepSpeed = 0.7;

            // Rotate neighbours
            grid.rotateMarked();

            // Remove lines of same direction cells 
            grid.deleteLines();

            dropNext = true;
            detected = false;
        }
        else
        {
            if (piece.onGround)
            {
                stepSpeed = 1.0;
                dropping = false;

                // If grid is filled
                if (max(piece.y, piece.y2) == 0)
                {
                    // Game over
                    gameState = 1;
                }
                else
                {
                    // Apply piece state to the grid cell
                    Cell* c = piece.underlyingCell1();
                    c.state = piece.state;

                    c = piece.underlyingCell2();
                    if (c !is null)
                        c.state = piece.state2;

                    // Hide the piece
                    piece.state = Cell.State.Empty;
                    piece.state2 = Cell.State.Empty;
                    piece.setPosition(grid.width / 2, 0);

                    dropNext = true;
                    stepSpeed = 0.05;
                }
            }
            else
                piece.fall(1);
        }
    }
    
    uint gameState = 0;

    void draw(double delta)
    {
        delta = min(delta, 1.0/60.0);
    
        // Update game
        timer += delta;
        if (timer >= stepSpeed)
        {
            timer = 0.0;
            
            if (gameState == 0)
                processGameStep();                
        }
        
        // Draw background
        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        background.bind(0.0);
        glPushMatrix();
        glScalef(cellWidth * grid.width, 
                 cellHeight * grid.height, 
                 cellWidth * grid.width);
        glBegin(GL_QUADS);
	    glTexCoord2f(0.0f, 0.0f); glVertex2f(0.0f, 0.0f);
	    glTexCoord2f(1.0f, 0.0f); glVertex2f(1.0f, 0.0f);
	    glTexCoord2f(1.0f, 1.0f); glVertex2f(1.0f, 1.0f);
	    glTexCoord2f(0.0f, 1.0f); glVertex2f(0.0f, 1.0f);
        glEnd();
        glPopMatrix();
        background.unbind();

        // Draw grid
        glColor4f(1.0f, 1.0f, 1.0f, 0.1f);
        glBegin(GL_LINES);
        foreach(x; 0..grid.width)
        {
            float xf = x * cellWidth;
            float yf = grid.height * cellHeight;
            glVertex3f(xf, 0, 0);
            glVertex3f(xf, yf, 0);
        }
        foreach(y; 0..grid.height)
        {
            float yf = y * cellHeight;
            float xf = grid.width * cellWidth;
            glVertex3f(0, yf, 0);
            glVertex3f(xf, yf, 0);
        }
        glEnd();
        
        // Draw active piece
        if (piece.y > -1)
        {
            drawCell(piece.x, piece.y, piece.state);
            if (piece.haveSecond)
                drawCell(piece.x2, piece.y2, piece.state2);
        }

        // Draw cells
        foreach(x; 0..grid.width)
        foreach(y; 0..grid.height)
        {
            Cell* c = &grid[grid.width * y + x];
            if (gameState == 0) 
                c.update(delta);

            if (c.rotating)
            {
                drawCell(x, y, c.state, 1.0f - c.rot / -90.0f, c.scale, c.rot);
                drawCell(x, y, c.nextState, c.rot / -90.0f, c.scale, c.rot + 90.0f);
                //drawCell(x, y, Cell.State.Highlight, (1.0f - c.rot / -90.0f) * 0.4f, c.scale, 0.0f);
            }
            else
                drawCell(x, y, c.state, c.scale, c.scale, c.rot);
        }
        
        if (gameState == 1 || gameState == 2)
        {
            glColor4f(0.0f, 0.0f, 0.0f, 0.6f);
            glPushMatrix();
            glScalef(cellWidth * grid.width, 
                     cellHeight * grid.height, 
                     cellWidth * grid.width);
            glBegin(GL_QUADS);
	        glTexCoord2f(0.0f, 0.0f); glVertex2f(0.0f, 0.0f);
	        glTexCoord2f(1.0f, 0.0f); glVertex2f(1.0f, 0.0f);
	        glTexCoord2f(1.0f, 1.0f); glVertex2f(1.0f, 1.0f);
	        glTexCoord2f(0.0f, 1.0f); glVertex2f(0.0f, 1.0f);
            glEnd();
            glPopMatrix();
        }

        if (gameState == 1)
        {
            glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
            txtGameOver.render("Game Over");
            txtRestart.render("Press <Enter> to restart");
        }

        if (gameState == 2)
        {
            glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
            txtPause.render("Pause");
        }
    }

    void setNext(Cell.State s)
    {
        nextIsDetermined = true;
        next = s;
    }

    Cell.State next;
    bool nextIsDetermined = false;

    void drawCell(
        uint x, 
        uint y, 
        Cell.State state, 
        float alpha = 1.0f, 
        float scale = 1.0f,
        float rot = 0.0f)
    {
        if (state == Cell.State.Empty)
            return;

        glColor4f(1.0f, 1.0f, 1.0f, alpha);

        auto tex = state in textures;
        if (tex !is null)
        {
            tex.bind(0.0);
        }
                
        glPushMatrix();
        glTranslatef(x * cellWidth + cellWidth * 0.5f, 
                     (grid.height-1) * cellHeight - 
                     y * cellHeight + cellHeight * 0.5f, 0.0f);
        glRotatef(rot, 0.0f, 0.0f, 1.0f);
        glScalef(cellWidth, cellHeight, cellWidth);
        glScalef(scale, scale, scale);
        glBegin(GL_QUADS);
	    glTexCoord2f(0.0f, 0.0f); glVertex2f(-0.5f, -0.5f);
	    glTexCoord2f(1.0f, 0.0f); glVertex2f(+0.5f, -0.5f);
	    glTexCoord2f(1.0f, 1.0f); glVertex2f(+0.5f, +0.5f);
	    glTexCoord2f(0.0f, 1.0f); glVertex2f(-0.5f, +0.5f);
        glEnd();
        glPopMatrix();
    
        glColor3f(1.0f, 1.0f, 1.0f);

        if (tex !is null)
            tex.unbind();
    }
}
